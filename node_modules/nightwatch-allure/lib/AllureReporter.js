"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const NightwatchAllureInterface_1 = require("./NightwatchAllureInterface");
const model_1 = require("./allure/model");
class AllureReporter {
    constructor(runtime) {
        this.runtime = runtime;
        this.suites = [];
        this.steps = [];
        this.runningTest = null;
    }
    getInterface() {
        return new NightwatchAllureInterface_1.NightwatchAllureInterface(this, this.runtime);
    }
    get currentSuite() {
        if (this.suites.length === 0) {
            return null;
        }
        return this.suites[this.suites.length - 1];
    }
    get currentStep() {
        if (this.steps.length > 0) {
            return this.steps[this.steps.length - 1];
        }
        return null;
    }
    get currentTest() {
        return this.runningTest;
    }
    set currentTest(test) {
        this.runningTest = test;
    }
    startSuite(suiteName) {
        const scope = this.currentSuite || this.runtime;
        const suite = scope.startGroup(suiteName || "Global");
        this.pushSuite(suite);
    }
    endSuite() {
        if (this.currentSuite !== null) {
            if (this.currentStep !== null) {
                this.currentStep.endStep();
            }
            this.currentSuite.endGroup();
            this.popSuite();
        }
    }
    startCase(test) {
        if (this.currentSuite === null) {
            throw new Error("No active suite");
        }
        this.currentTest = this.currentSuite.startTest(test.testName);
        this.currentTest.setEnd(test.timeMs);
        this.currentTest.fullName = test.testName;
        const currentDate = new Date();
        this.currentTest.addLabel(model_1.LabelName.TAG, "" + currentDate);
        if (test.reportPrefix) {
            this.currentTest.addLabel(model_1.LabelName.TAG, test.reportPrefix);
            this.currentTest.addParameter('Machine', test.reportPrefix);
        }
        this.currentTest.historyId = crypto_1.createHash("md5")
            .update(test.reportPrefix + test.testName)
            .digest("hex");
        this.currentTest.stage = model_1.Stage.RUNNING;
    }
    passTestCase(test) {
        if (this.currentTest === null) {
            this.startCase(test);
        }
        this.endTest(model_1.Status.PASSED);
    }
    pendingTestCase(test) {
        this.startCase(test);
        this.endTest(model_1.Status.SKIPPED, { message: "Test ignored" });
    }
    partialTestCase(test) {
        this.startCase(test);
        this.endTest(model_1.Status.BROKEN, { message: "Test ignored" });
    }
    failTestCase(test, error) {
        if (this.currentTest === null) {
            this.startCase(test);
        }
        else {
            const latestStatus = this.currentTest.status;
            if (latestStatus === model_1.Status.FAILED || latestStatus === model_1.Status.BROKEN) {
                return;
            }
        }
        const status = error.name === "AssertionError" ? model_1.Status.FAILED : model_1.Status.BROKEN;
        this.endTest(status, { message: error.message, trace: error.stack });
    }
    writeAttachment(content, type) {
        return this.runtime.writeAttachment(content, type);
    }
    setTestStatus(status) {
        if (this.currentTest === null) {
            throw new Error("setTestStatus while no test is running");
        }
        this.currentTest.status = status;
    }
    setTestDescription(description) {
        if (this.currentTest === null) {
            throw new Error("setTestDescription while no test is running");
        }
        this.currentTest.description = description;
    }
    setTestDetailsTrace(detailsTrace) {
        if (this.currentTest === null) {
            throw new Error("setTestDetailsTrace while no test is running");
        }
        this.currentTest.statusDetails = { message: "Error", trace: detailsTrace };
    }
    setTestDetailsMessage(detailsMessage) {
        if (this.currentTest === null) {
            throw new Error("setTestDetailsMessage while no test is running");
        }
        this.currentTest.detailsMessage = detailsMessage;
    }
    addTestAttachment(name, content, type) {
        if (this.currentTest === null) {
            throw new Error("addTestAttachment while no test is running");
        }
        const file = this.writeAttachment(content, type);
        this.currentTest.addAttachment(name, type, file);
    }
    pushStep(step) {
        this.steps.push(step);
    }
    popStep() {
        this.steps.pop();
    }
    pushSuite(suite) {
        this.suites.push(suite);
    }
    popSuite() {
        this.suites.pop();
    }
    completeTest() {
        if (this.currentTest === null) {
            throw new Error("completeTest while no test is running");
        }
        this.currentTest.endTest();
    }
    endTest(status, details) {
        if (this.currentTest === null) {
            throw new Error("endTest while no test is running");
        }
        if (details) {
            this.currentTest.statusDetails = details;
        }
        this.currentTest.status = status;
        this.currentTest.stage = model_1.Stage.FINISHED;
        this.currentTest.endTest();
    }
}
exports.AllureReporter = AllureReporter;
//# sourceMappingURL=AllureReporter.js.map